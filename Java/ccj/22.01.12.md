## [Java](#java-1)

[생각](###생각)  
[정리](###정리)
---
###생각

#### 💡 Java 8에 추가된 기능은 무엇이 있나요?
- 함수형 프로그래밍 기능
    - java.time 패키지와 스트림 API, 람다 표현식
    
#### 💡 Lambda란 무엇이고 어떠한 장점이 있는가?
- ? 
    - 식별자 없이 실행가능한 함수
    - 코드를 줄여 간단하게 작성하고 가독성이 증가

#### 💡 Stream API 특징이나 장점은 무엇이 있나요?
- 멀티 
    - 원본 데이터를 변경하지 않고 가공된 데이터를 추출

#### 💡 Garbage Collector(GC)란?
- 자바에서 사용하고 참조가 없어진 메모리를 정리
    - 개발자가 따로 메모리 해제할 필요없이 힙 영역에서 더이상 사용되지 않을 객체들을 찾아 메모리 해제하여
    메모리를 자동으로 정리해주는 것

#### 💡 GC에 의해 변수가 초기화되는 시점을 설정해주세요.
- 참조가 없어질때
    - 지역변수는 scope 가 끝나거나 변수에 다른 객체를 삽입하면
    - 전역변수의 경우 프로그램이 종료되면 초기화
    - GC 동작원리
    
#### 💡 JAVA에서 바이트코드에 대해 설명해보세요.
- ?
    - 자바 바이트 코드란 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미

#### 💡 예외처리 방법을 설명해주세요.
- try - catch
- throw Error
    - [복구형] Try/Catch 블록
        - 예외 가능성 있는 블록 try로 감싸고 처리는 catch에 받아서 함
        - try - with - resource
    - [회피형] Throw 키워드 선언
        - 메소드 끝단에 throws Exception을 선언 처리
    - [전환형] catch에서 다른 예외 던지는 것
        - 호출 측에서 에러의 타입을 명확하게 인지할 수 있도록 예외를 던져주는 것
    
#### 💡 JAVA 동작 원리
- ?

#### 💡 자바에서 쓰레드를 구현하기 위한 2가지 방법을 간단하게 설명하시오.
- ?
    - Runnable 인터페이스를 확장해 run() 메소드 구현
    - Thread 클래스를 상속받고 run() 메소드를 오버라이딩해 구현
    
#### 💡 Collection 정의와 종류를 말씀해주세요
- I DONT KNOW
    - 컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
    
    - Collection 인터페이스
        - List 인터페이스는 순서가 있는 데이터 집합, 중복 허용
        - ArrayList, LinkedList
    - Map 인터페이스
        - 키와 값 쌍으로 이뤄지는 데이터 집합으로 키 값은 중복을 허용하지 않음
        - HashMap, TreeMap
    
---
###정리
#### Java8에 추가된 기능
- Metaspace
    - 메모리의 관점에서 가장 큰 변화로는 PermGen 이 사라지고 Metaspace 가 이를 대체함
    - PermGen 은 자바 7까지 클래스의 메타데이터를 저장하던 영역이었고 Heap 의 일부 (힙 메모리 영역중 하나)
    - 자바 8부터 클래스들은 모두 힙이 아닌 네이티브 메모리를 사용하는 Metaspace 에 할당됨
    
- Heap
    - Old
    - Eden
    - S0
    - S1
    
- 람다 표현식
- 메소드 참조
- 스트림
- Default Method
- Optional
- joda Time

#### 람다 표현식
- 익명함수 : 이름을 가지지 않는 함수
- 일급객체 : 함수를 값으로 사용할 수도 있으며 파라미터로 전달 및 변수에 대입 하기와 같은 연산도 가능

장점
- 코드의 간결성 - 람다를 사용하면 불필요한 반복문의 삭제가 가능하며 복잡한 식을 단순하게 표현
- 지연연산 수행 - ?
- 병렬처리 가능 - 멀티 쓰레드를 활용

단점
- 호출이 까다롭
- 람다 stream 사용시 단순 반복문 보다 성능 떨어짐
- 오히려 가독성 낮아질수도

#### 함수형 인터페이스
- @FunctionalInterFace
    - 일반적으로 구현해야 할 추상 메소드가 하나만 정의된 인터페이스
    
#### Stream API
- 다양한 데이터를 표준화된 방법으로 다루기 위한 라이브러리
- 스트림 생성, 중간 연산, 최종 연산

특징
- 데이터 변경하지 않음
- 1회용
- `지연 연산` : 불필요한 연산을 피함 : 모든 조건을 만족하는 순간 연산을 시작한다!!!!! 
- 병렬 실행

#### GC
- 힙 영역에 있는 참조되지 않은(unreachable) 객체를 메모리에서 제거하여 메모리 공간을 확보하는 것
- mark : GC가 스택의 모든 변수를 스캔하면서 각각 어떤 오브젝트를 레퍼런스 하고 있는지 찾는 과정 (레퍼런스된 오브젝트가 레퍼런스하고 있는 오브젝트로 찾음)
    - marking 작업을 위해 모든 스레드는 중단됨
- sweep : mark 되어있지 않은 모든 오브젝트들을 힙에서 제거하는 과정

프로세스
- 새로운 오브젝트 Eden 영역에 할당
- Eden 가득 차면 MinorGC 발생
- Reachable 오브젝트들은 S0으로 옮겨지고 unReachable 오브젝트는 메모리에서 제거
- 또 MinorGC가 발생하면 위와 같은 과정을 반복하고 S0에있던 Reachable 오브젝트들은 S1으로 옮겨짐
- 모든 Survivor Space 에서 다른 Survivor Space 로 이동하는 과정에는 age 값이 증가함
- 계속해서 반복하다가 특정 age 값 이상이 되면 Old Generation 으로 옮겨짐 (Promotion)
- Old Generation 이 가득 차게 되면 MajorGC 발생

종류
- Serial GC
    - 새로운 메모리 할당을 빠르게 하기 위해 기존의 메모리에 있던 오브젝트들을 힙의 시작위치로 옮겨 놓는 방법 (빈 공간을 없애고 압축!)
    
- Parallel GC
    - young generation 에 대한 가비지 컬렉션 수행시 멀티스레드를 사용함
    - But 싱글 CPU 라면 디폴트 가비지 컬렉터(Serial)가 사용됨
    - 가비지 컬렉터 스레드 개수는 디폴트로 CPU 개수만큼 할당됨
    
- Concurrent Mark Sweep(CMS) Collector
    - 애플리케이션 스레드와 동시에 가비지 컬렉션 작업을 가져가면서 stop-the-world 시간을 최소화하는 GC
    - 일반적으로 CMS 컬렉터는 살아있는 오브젝트들에 대한 compact 작업을 수행하지 않으므로, 메모리 파편화가 문제되면 더 큰 힙사이즈를 할당해야함
    
- G1 Garbage Collector
    - java 7 부터 사용가능함
    - 장기적으로 CMS 컬렉터를 대체하기 위해 만들어짐
    - 가장 큰 장점은 성능 가장 빠름
    ...!