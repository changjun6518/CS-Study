### 정렬

#### 생각

- 선택 정렬
    - 전체를 스캔하면서 가장 작은 것을 맨 앞 숫자와 바꾸는 전략
    - 시간복잡도 : N x ( N+1 )/2 => O(N2)
    
```
public static void main(String[] args) {
        int[] arr = {3, 4, 8, 5, 6, 7, 1, 2, 3, 4};
        int index;

        for (int i = 0; i < arr.length; i++) {
            index = i;
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[index] > arr[j]) {
                    index = j;
                }
            }
            int temp = arr[i];
            arr[i] = arr[index];
            arr[index] = temp;
        }

        System.out.println(Arrays.toString(arr));
//        [1, 2, 3, 3, 4, 4, 5, 6, 7, 8]

    }
```

- 삽입 정렬
  - 삽입이 완료된 원소는 항상 오름차순을 유지함
  - 인덱스 하나씩 체크하면서 자기보다 작은 값 앞까지 스왑하면서 진행
  - 시간복잡도 : O(N2)
  - 데이터가 거의 정렬되어 있으면 O(N)의 시간 복잡도를 지님 (퀵보다 빠를수도) (어떤상황?)
```
  int[] arr = {3, 4, 8, 5, 6, 7, 1, 2, 3, 4};

  for (int i = 1; i < arr.length ; i++) {
      for (int j = i; j >= 1; j--) {
          if (arr[j] < arr[j - 1]) {
              int temp = arr[j];
              arr[j] = arr[j - 1];
              arr[j - 1] = temp;
          } else {
              break;
          }
      }
  }

  System.out.println(Arrays.toString(arr));
```

```
for (int i = 1; i < arr.length; i++) {
    int indexValue = arr[i];
    int prev = i - 1;
    while (prev >= 0 && arr[prev] > indexValue) {
        arr[prev + 1] = arr[prev];
        prev--;
    }
    arr[prev + 1] = indexValue;
}
```

- 퀵 정렬
  - 가장 많이 사용되는 정렬
  - 기준 설정하고 기준보다 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는 방식
  - 재귀로 품
  - 시간 복잡도는 O(NlogN) 최악은 O(N2)
  - 반씩 나눠서 호출해 nlogn, 배열이 정렬되어 있을 경우 한쪽으로 치우친 트리여서 높이가 n이 되면서 n2이 됨
  - 정렬이 되어있는 경우 최악의 시간 복잡도를 가지는데 그런 데이터가 주어질 확률이 낮다
```
  public static void main(String[] args) {
        int[] arr = {3, 4, 8, 5, 6, 7, 1, 2, 3, 4};

        // 1. swap 함수
        // 2. 재귀로 반씩 쪼개 주면서 넘기기
        // 3. 리스트 안에서 큰수와 작은수 교체
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    private static void quickSort(int[] arr, int lo, int hi) {
        if (lo >= hi) {
            return;
        }
        int pivot = partition(arr, lo, hi);

        quickSort(arr, lo, pivot - 1);
        quickSort(arr, pivot + 1, hi);
    }

    private static int partition(int[] arr, int lo, int hi) {
        int pivot = arr[lo];
        int left = lo;
        while (lo < hi) {
            while (arr[hi] > pivot && lo < hi) {
                hi--;
            }

            while (arr[lo] <= pivot && lo < hi) {
                lo++;
            }

            swap(arr, lo, hi);
        }

        swap(arr, left, lo);

        return lo;
    }

    private static void swap(int[] arr, int lo, int hi) {
        int temp = arr[lo];
        arr[lo] = arr[hi];
        arr[hi] = temp;
    }
```

- 계수 정렬
  - 특정 조건 부합할때 매우 빠른 정렬
  - 모든 데이터가 양의 정수인 상황에서 데이터 개수가 N 테이터 최대값이 K일때 최악의 경우도 O(N+K) 보장
  - 데이터의 크기 범위가 제한 즉 알고있을때 사용가능 (일반적으로 최소 최대 차가 1,000,000 이내일때 효과적)
  - 기수 정렬과 더불어 가장 빠른 정렬 (보통 기수정렬이 더 느리고 복잡한데 처리할 수 있는 정수의 크기가 더 큼)
  - 공간 복잡도는 (N+K)
  
```
  public static void main(String[] args) {
      int[] arr = {3, 4, 8, 5, 6, 7, 1, 2, 3, 4};
  
      int[] countList = new int[arr.length];
      ArrayList<Integer> arrayList = new ArrayList<>();
      for (int i = 0; i < arr.length; i++) {
          countList[arr[i]]++;
      }
      for (int i = 0; i < arr.length; i++) {
          if (countList[i] != 0) {
              for (int j = 0; j < countList[i]; j++) {
                  arrayList.add(i);
              }
          }
      }
  
      System.out.println(arrayList);
  
  }
```

- 버블 정렬
  - 인접한 두 원소의 대소를 비교하고 조건에 맞지 않으면 자리 교환
  - 시간 복잡도 O(n2), 공간 복잡도 O(n)
  - 처음부터 끝까지 대소비교하면서 자리를 바꾸고 맨뒤는 제일 큰 원소가 되면서 대소비교에서 제외
  
```
public static void main(String[] args) {
    int[] arr = {3, 4, 8, 5, 6, 7, 1, 2, 3, 4};

    for (int i = 0; i < arr.length; i++) {
        for (int j = 1; j < arr.length - i; j++) {
            if (arr[j - 1] > arr[j]) {
                swap(arr, j-1, j );
            }
        }
    }

    System.out.println(Arrays.toString(arr));
}
```